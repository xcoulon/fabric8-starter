// Code generated by goagen v1.3.0, DO NOT EDIT.
//
// API "fabric8-starter": Application User Types
//
// Command:
// $ goagen
// --design=github.com/fabric8-services/fabric8-starter/design
// --out=$(GOPATH)/src/github.com/fabric8-services/fabric8-starter
// --version=v1.3.0

package app

import (
	"github.com/goadesign/goa"
	uuid "github.com/satori/go.uuid"
	"time"
	"unicode/utf8"
)

// dataKindUUID user type.
type dataKindUUID struct {
	// UUID of the object
	ID   *uuid.UUID `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Type *string    `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the dataKindUUID type instance.
func (ut *dataKindUUID) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.ID == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "id"))
	}
	return
}

// Publicize creates DataKindUUID from dataKindUUID
func (ut *dataKindUUID) Publicize() *DataKindUUID {
	var pub DataKindUUID
	if ut.ID != nil {
		pub.ID = *ut.ID
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// DataKindUUID user type.
type DataKindUUID struct {
	// UUID of the object
	ID   uuid.UUID `form:"id" json:"id" xml:"id"`
	Type string    `form:"type" json:"type" xml:"type"`
}

// Validate validates the DataKindUUID type instance.
func (ut *DataKindUUID) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}

	return
}

// genericData user type.
type genericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *genericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Publicize creates GenericData from genericData
func (ut *genericData) Publicize() *GenericData {
	var pub GenericData
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Type != nil {
		pub.Type = ut.Type
	}
	return &pub
}

// GenericData user type.
type GenericData struct {
	// UUID of the object
	ID    *string       `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links *GenericLinks `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Type  *string       `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// genericLinks user type.
type genericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Publicize creates GenericLinks from genericLinks
func (ut *genericLinks) Publicize() *GenericLinks {
	var pub GenericLinks
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Related != nil {
		pub.Related = ut.Related
	}
	if ut.Self != nil {
		pub.Self = ut.Self
	}
	return &pub
}

// GenericLinks user type.
type GenericLinks struct {
	Meta    map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	Related *string                `form:"related,omitempty" json:"related,omitempty" xml:"related,omitempty"`
	Self    *string                `form:"self,omitempty" json:"self,omitempty" xml:"self,omitempty"`
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type jSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail *string `form:"detail,omitempty" json:"detail,omitempty" xml:"detail,omitempty"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*jSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the jSONAPIError type instance.
func (ut *jSONAPIError) Validate() (err error) {
	if ut.Detail == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "detail"))
	}
	return
}

// Publicize creates JSONAPIError from jSONAPIError
func (ut *jSONAPIError) Publicize() *JSONAPIError {
	var pub JSONAPIError
	if ut.Code != nil {
		pub.Code = ut.Code
	}
	if ut.Detail != nil {
		pub.Detail = *ut.Detail
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = make(map[string]*JSONAPILink, len(ut.Links))
		for k2, v2 := range ut.Links {
			pubk2 := k2
			var pubv2 *JSONAPILink
			if v2 != nil {
				pubv2 = v2.Publicize()
			}
			pub.Links[pubk2] = pubv2
		}
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	if ut.Source != nil {
		pub.Source = ut.Source
	}
	if ut.Status != nil {
		pub.Status = ut.Status
	}
	if ut.Title != nil {
		pub.Title = ut.Title
	}
	return &pub
}

// Error objects provide additional information about problems encountered while
// performing an operation. Error objects MUST be returned as an array keyed by errors in the
// top level of a JSON API document.
//
// See. also http://jsonapi.org/format/#error-objects.
type JSONAPIError struct {
	// an application-specific error code, expressed as a string value.
	Code *string `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// a human-readable explanation specific to this occurrence of the problem.
	// Like title, this field’s value can be localized.
	Detail string `form:"detail" json:"detail" xml:"detail"`
	// a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// a links object containing the following members:
	// * about: a link that leads to further details about this particular occurrence of the problem.
	Links map[string]*JSONAPILink `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	// a meta object containing non-standard meta-information about the error
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
	// an object containing references to the source of the error,
	// optionally including any of the following members
	//
	// * pointer: a JSON Pointer [RFC6901] to the associated entity in the request document [e.g. "/data" for a primary data object,
	//            or "/data/attributes/title" for a specific attribute].
	// * parameter: a string indicating which URI query parameter caused the error.
	Source map[string]interface{} `form:"source,omitempty" json:"source,omitempty" xml:"source,omitempty"`
	// the HTTP status code applicable to this problem, expressed as a string value.
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// a short, human-readable summary of the problem that SHOULD NOT
	// change from occurrence to occurrence of the problem, except for purposes of localization.
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
}

// Validate validates the JSONAPIError type instance.
func (ut *JSONAPIError) Validate() (err error) {
	if ut.Detail == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "detail"))
	}
	return
}

// See also http://jsonapi.org/format/#document-links.
type jSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates JSONAPILink from jSONAPILink
func (ut *jSONAPILink) Publicize() *JSONAPILink {
	var pub JSONAPILink
	if ut.Href != nil {
		pub.Href = ut.Href
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// See also http://jsonapi.org/format/#document-links.
type JSONAPILink struct {
	// a string containing the link's URL.
	Href *string `form:"href,omitempty" json:"href,omitempty" xml:"href,omitempty"`
	// a meta object containing non-standard meta-information about the link.
	Meta map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// JSONAPI store for the data of a Label. See also http://jsonapi.org/format/#document-resource-object
type label struct {
	Attributes *labelAttributes `form:"attributes,omitempty" json:"attributes,omitempty" xml:"attributes,omitempty"`
	// ID of label
	ID            *uuid.UUID      `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *genericLinks   `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *labelRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          *string         `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
}

// Validate validates the label type instance.
func (ut *label) Validate() (err error) {
	if ut.Type == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`request`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if ut.Type != nil {
		if !(*ut.Type == "labels") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError(`request.type`, *ut.Type, []interface{}{"labels"}))
		}
	}
	return
}

// Publicize creates Label from label
func (ut *label) Publicize() *Label {
	var pub Label
	if ut.Attributes != nil {
		pub.Attributes = ut.Attributes.Publicize()
	}
	if ut.ID != nil {
		pub.ID = ut.ID
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Relationships != nil {
		pub.Relationships = ut.Relationships.Publicize()
	}
	if ut.Type != nil {
		pub.Type = *ut.Type
	}
	return &pub
}

// JSONAPI store for the data of a Label. See also http://jsonapi.org/format/#document-resource-object
type Label struct {
	Attributes *LabelAttributes `form:"attributes" json:"attributes" xml:"attributes"`
	// ID of label
	ID            *uuid.UUID      `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	Links         *GenericLinks   `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Relationships *LabelRelations `form:"relationships,omitempty" json:"relationships,omitempty" xml:"relationships,omitempty"`
	Type          string          `form:"type" json:"type" xml:"type"`
}

// Validate validates the Label type instance.
func (ut *Label) Validate() (err error) {
	if ut.Type == "" {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "type"))
	}
	if ut.Attributes == nil {
		err = goa.MergeErrors(err, goa.MissingAttributeError(`type`, "attributes"))
	}
	if ut.Attributes != nil {
		if err2 := ut.Attributes.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if !(ut.Type == "labels") {
		err = goa.MergeErrors(err, goa.InvalidEnumValueError(`type.type`, ut.Type, []interface{}{"labels"}))
	}
	return
}

// JSONAPI store for all the "attributes" of a Label. See also http://jsonapi.org/format/#document-resource-object-attributes
type labelAttributes struct {
	// Background color in hex code format. See also http://www.color-hex.com
	BackgroundColor *string `form:"background-color,omitempty" json:"background-color,omitempty" xml:"background-color,omitempty"`
	// Border color in hex code format. See also http://www.color-hex.com
	BorderColor *string `form:"border-color,omitempty" json:"border-color,omitempty" xml:"border-color,omitempty"`
	// When the label was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The Label name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Text color in hex code format. See also http://www.color-hex.com
	TextColor *string `form:"text-color,omitempty" json:"text-color,omitempty" xml:"text-color,omitempty"`
	// When the label was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the labelAttributes type instance.
func (ut *labelAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`request.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`request.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	return
}

// Publicize creates LabelAttributes from labelAttributes
func (ut *labelAttributes) Publicize() *LabelAttributes {
	var pub LabelAttributes
	if ut.BackgroundColor != nil {
		pub.BackgroundColor = ut.BackgroundColor
	}
	if ut.BorderColor != nil {
		pub.BorderColor = ut.BorderColor
	}
	if ut.CreatedAt != nil {
		pub.CreatedAt = ut.CreatedAt
	}
	if ut.Name != nil {
		pub.Name = ut.Name
	}
	if ut.TextColor != nil {
		pub.TextColor = ut.TextColor
	}
	if ut.UpdatedAt != nil {
		pub.UpdatedAt = ut.UpdatedAt
	}
	if ut.Version != nil {
		pub.Version = ut.Version
	}
	return &pub
}

// JSONAPI store for all the "attributes" of a Label. See also http://jsonapi.org/format/#document-resource-object-attributes
type LabelAttributes struct {
	// Background color in hex code format. See also http://www.color-hex.com
	BackgroundColor *string `form:"background-color,omitempty" json:"background-color,omitempty" xml:"background-color,omitempty"`
	// Border color in hex code format. See also http://www.color-hex.com
	BorderColor *string `form:"border-color,omitempty" json:"border-color,omitempty" xml:"border-color,omitempty"`
	// When the label was created
	CreatedAt *time.Time `form:"created-at,omitempty" json:"created-at,omitempty" xml:"created-at,omitempty"`
	// The Label name
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// Text color in hex code format. See also http://www.color-hex.com
	TextColor *string `form:"text-color,omitempty" json:"text-color,omitempty" xml:"text-color,omitempty"`
	// When the label was updated
	UpdatedAt *time.Time `form:"updated-at,omitempty" json:"updated-at,omitempty" xml:"updated-at,omitempty"`
	// Version for optimistic concurrency control (optional during creating)
	Version *int `form:"version,omitempty" json:"version,omitempty" xml:"version,omitempty"`
}

// Validate validates the LabelAttributes type instance.
func (ut *LabelAttributes) Validate() (err error) {
	if ut.Name != nil {
		if ok := goa.ValidatePattern(`^[^_|-].*`, *ut.Name); !ok {
			err = goa.MergeErrors(err, goa.InvalidPatternError(`type.name`, *ut.Name, `^[^_|-].*`))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 1, true))
		}
	}
	if ut.Name != nil {
		if utf8.RuneCountInString(*ut.Name) > 63 {
			err = goa.MergeErrors(err, goa.InvalidLengthError(`type.name`, *ut.Name, utf8.RuneCountInString(*ut.Name), 63, false))
		}
	}
	return
}

// labelRelations user type.
type labelRelations struct {
	// This defines the owning space
	Space *relationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// Publicize creates LabelRelations from labelRelations
func (ut *labelRelations) Publicize() *LabelRelations {
	var pub LabelRelations
	if ut.Space != nil {
		pub.Space = ut.Space.Publicize()
	}
	return &pub
}

// LabelRelations user type.
type LabelRelations struct {
	// This defines the owning space
	Space *RelationGeneric `form:"space,omitempty" json:"space,omitempty" xml:"space,omitempty"`
}

// relationGeneric user type.
type relationGeneric struct {
	Data  *genericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGeneric from relationGeneric
func (ut *relationGeneric) Publicize() *RelationGeneric {
	var pub RelationGeneric
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGeneric user type.
type RelationGeneric struct {
	Data  *GenericData           `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationGenericList user type.
type relationGenericList struct {
	Data  []*genericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Publicize creates RelationGenericList from relationGenericList
func (ut *relationGenericList) Publicize() *RelationGenericList {
	var pub RelationGenericList
	if ut.Data != nil {
		pub.Data = make([]*GenericData, len(ut.Data))
		for i2, elem2 := range ut.Data {
			pub.Data[i2] = elem2.Publicize()
		}
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationGenericList user type.
type RelationGenericList struct {
	Data  []*GenericData         `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// relationKindUUID user type.
type relationKindUUID struct {
	Data  *dataKindUUID          `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *genericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the relationKindUUID type instance.
func (ut *relationKindUUID) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// Publicize creates RelationKindUUID from relationKindUUID
func (ut *relationKindUUID) Publicize() *RelationKindUUID {
	var pub RelationKindUUID
	if ut.Data != nil {
		pub.Data = ut.Data.Publicize()
	}
	if ut.Links != nil {
		pub.Links = ut.Links.Publicize()
	}
	if ut.Meta != nil {
		pub.Meta = ut.Meta
	}
	return &pub
}

// RelationKindUUID user type.
type RelationKindUUID struct {
	Data  *DataKindUUID          `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	Links *GenericLinks          `form:"links,omitempty" json:"links,omitempty" xml:"links,omitempty"`
	Meta  map[string]interface{} `form:"meta,omitempty" json:"meta,omitempty" xml:"meta,omitempty"`
}

// Validate validates the RelationKindUUID type instance.
func (ut *RelationKindUUID) Validate() (err error) {
	if ut.Data != nil {
		if err2 := ut.Data.Validate(); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// pagingLinks user type.
type pagingLinks struct {
	Filters *string `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	First   *string `form:"first,omitempty" json:"first,omitempty" xml:"first,omitempty"`
	Last    *string `form:"last,omitempty" json:"last,omitempty" xml:"last,omitempty"`
	Next    *string `form:"next,omitempty" json:"next,omitempty" xml:"next,omitempty"`
	Prev    *string `form:"prev,omitempty" json:"prev,omitempty" xml:"prev,omitempty"`
}

// Publicize creates PagingLinks from pagingLinks
func (ut *pagingLinks) Publicize() *PagingLinks {
	var pub PagingLinks
	if ut.Filters != nil {
		pub.Filters = ut.Filters
	}
	if ut.First != nil {
		pub.First = ut.First
	}
	if ut.Last != nil {
		pub.Last = ut.Last
	}
	if ut.Next != nil {
		pub.Next = ut.Next
	}
	if ut.Prev != nil {
		pub.Prev = ut.Prev
	}
	return &pub
}

// PagingLinks user type.
type PagingLinks struct {
	Filters *string `form:"filters,omitempty" json:"filters,omitempty" xml:"filters,omitempty"`
	First   *string `form:"first,omitempty" json:"first,omitempty" xml:"first,omitempty"`
	Last    *string `form:"last,omitempty" json:"last,omitempty" xml:"last,omitempty"`
	Next    *string `form:"next,omitempty" json:"next,omitempty" xml:"next,omitempty"`
	Prev    *string `form:"prev,omitempty" json:"prev,omitempty" xml:"prev,omitempty"`
}
